<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Elements - Editorial by HTML5 UP</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									
								</header>

							<!-- Content -->
								<section>
									<header class="main">
										<h1>Elements</h1>
									</header>

									<!-- Content -->
										<h2 id="content">BUSINESS CASE STUDY :-</h2>
										<p><strong>1.Biodiversity Conservation</strong></p>
										<p>	<strong>a.Arrays</strong><p>
										<p><strong>b.Queue</strong></p>
										<p><strong>c.Prim's Algorithm - Prim's algorithm can help design protected areas for wildlife habitats and wetlands by optimizing connectivity and minimizing costs. Nodes represent key habitats or wetlands, and edges are weighted by the cost or feasibility of connecting them (e.g., land acquisition or restoration costs). The algorithm identifies a network that links all critical areas with minimal cost, ensuring habitat connectivity and ecosystem preservation. This approach supports efficient resource use and maximizes conservation impact.<strong>
										<p>								
										<p><strong>2.Traffic and Transportation System-<strong></p>
											<p>a.Arrays</p>
											<p>b.Queue</p>
											<p><strong>c.Kruskal's Algorithm - </strong> Kruskal's algorithm can minimize economic disruption by optimizing resource allocation. It identifies the most cost-effective connections between affected areas, prioritizing critical infrastructure restoration and efficient supply chains, ensuring recovery efforts are cost-effective and promote financial stability.</p>

										<div class="row">
											<div class="col-6 col-12-small">
												<h3><strong>SDG'S Involved in the case study:-</strong></h3>
												<p>SDG 1.No Poverty</p>
												<p>SDG 8.Decent Work and Economic Growth</p>
												<p>SDG 9.Industry,Innovation and Infrastructure</p>
												<p>SDG 11.Sustainable Cities and Communities</p>
												<p>SDG 17.Partenship for the Goals</p>
												<p>SDG 13.Responsible Consumption and Production</p>
											</div>
											
											<!-- Break -->
											<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Case Studies</title>
    <style>
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>

<h1>BUSINESS CASE STUDIES</h1>
<button onclick="showCode('Biodiversity')">Biodiversity Conservation</button>
<button onclick="showCode('Economic')">Economic Disruption system</button>

<div id="contentContainer">
    <p class="placeholder-text">Codes will be displayed here</p>
</div>

<script>
// Define the case study code for Biodiversity Conservation (Prim's Algorithm)
const biodiversityCode = `
#include <iostream>
#include <climits>

using namespace std;

#define V 5 // Number of vertices in the graph

// Function to find the vertex with the smallest key value that is not yet included in MST
int findMinVertex(int key[], bool inMST[]) {
    int minKey = INT_MAX, minIndex;

    for (int v = 0; v < V; ++v) {
        if (!inMST[v] && key[v] < minKey) {
            minKey = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

void primMST(int graph[V][V]) {
    int parent[V];  // Array to store constructed MST
    int key[V];     // Key values used to pick minimum weight edge
    bool inMST[V];  // To represent vertices included in MST

    // Initialize all keys as infinite and inMST as false
    for (int i = 0; i < V; ++i) {
        key[i] = INT_MAX;
        inMST[i] = false;
    }

    // Starting from the first vertex
    key[0] = 0;      // Make key 0 so that this vertex is picked first
    parent[0] = -1;  // First node is always root of MST

    // The MST will have V vertices
    for (int count = 0; count < V - 1; ++count) {
        // Pick the minimum key vertex not yet included in MST
        int u = findMinVertex(key, inMST);
        inMST[u] = true;

        // Update key and parent for adjacent vertices of u
        for (int v = 0; v < V; ++v) {
            if (graph[u][v] && !inMST[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    // Print the edges of the MST
    cout << "Edge \tWeight\n";
    for (int i = 1; i < V; ++i) {
        cout << parent[i] << " - " << i << "\t" << graph[parent[i]][i] << endl;
    }
}

int main() {
    // Graph represented as an adjacency matrix
    int graph[V][V] = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    primMST(graph);

    return 0;
}
`;

// Define the case study code for Economic Disruption System
const economicCode = `
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Structure to represent an edge in the graph
struct Edge {
    int src, dest, weight;
};

// Function to find the parent of a node in the disjoint-set
int findParent(int node, vector<int>& parent) {
    while (parent[node] != node) {
        node = parent[node];
    }
    return node;
}

// Kruskal's algorithm for finding Minimum Spanning Tree (MST)
void kruskal(int V, vector<Edge>& edges) {
    // Sort edges based on weight
    sort(edges.begin(), edges.end(), [](Edge a, Edge b) {
        return a.weight < b.weight;
    });

    vector<int> parent(V); // Parent array for union-find
    for (int i = 0; i < V; i++) {
        parent[i] = i; // Initialize each node as its own parent
    }

    vector<Edge> mst; // To store the edges of the MST

    // Process each edge and apply union-find
    for (Edge& edge : edges) {
        int u = edge.src;
        int v = edge.dest;

        int parentU = findParent(u, parent);
        int parentV = findParent(v, parent);

        if (parentU != parentV) { // If adding this edge doesn't form a cycle
            mst.push_back(edge);
            parent[parentU] = parentV; // Union of sets
        }
    }

    // Display the MST
    cout << "Edges in the Minimum Spanning Tree:" << endl;
    for (Edge& edge : mst) {
        cout << edge.src << " -- " << edge.dest << " == " << edge.weight << endl;
    }
}

int main() {
    int V, E;

    // Input number of vertices and edges
    cout << "Enter the number of vertices: ";
    cin >> V;
    cout << "Enter the number of edges: ";
    cin >> E;

    vector<Edge> edges(E);

    // Input edges (source, destination, weight)
    cout << "Enter edges (source, destination, weight):" << endl;
    for (int i = 0; i < E; i++) {
        cin >> edges[i].src >> edges[i].dest >> edges[i].weight;
    }

    // Call Kruskal's algorithm to find MST
    kruskal(V, edges);

    return 0;
}
`;

// Function to show the corresponding code based on the case study clicked
function showCode(caseStudy) {
    const contentContainer = document.getElementById('contentContainer');
    
    // Check the case study and display the code in <pre> tag
    if (caseStudy === 'Biodiversity') {
        contentContainer.innerHTML = '<pre>' + biodiversityCode + '</pre>';
    } else if (caseStudy === 'Economic') {
        contentContainer.innerHTML = '<pre>' + economicCode + '</pre>';
    }
}
</script>

</body>
</html>





									<hr class="major" />

									<!-- Elements -->
										
										<div class="row gtr-200">
											<div class="col-6 col-12-medium">

												<!-- Text stuff -->
													

												<!-- Lists -->

													
													
														

													

												<!-- Blockquote -->
												<!-- Table -->
											</div>
											<div class="col-6 col-12-medium">

												<!-- Buttons -->


												<!-- Form -->
													

												<!-- Image -->
													

													

												<!-- Box -->
													

												<!-- Preformatted Code -->
													

											</div>
										</div>

								</section>

						</div>
					</div>

				<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">

							<!-- Search -->
								<section id="search" class="alt">
									<form method="post" action="#">
										<input type="text" name="query" id="query" placeholder="Search" />
									</form>
								</section>

							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
										<li><a href="index.html">Homepage</a></li>
										<li><a href="generic.html">COURSE INTRODUCTION</a></li>
										<li><a href="elements.html">MY WORK</a></li>
										<li>
								</nav>


		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>